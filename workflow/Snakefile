#!/usr/bin/env snakemake


import os
import sys


shell.executable("bash")


workdir: "."


rule all:
    input:
        expand("{barcode}.fin", barcode=config["barcodes"].keys()),


rule gather_fastqs:
    input:
        fastqs=lambda wildcards: config["barcodes"][wildcards.barcode]["fastqs"],
    output:
        "IRMA/{barcode}.fastq",
    shell:
        "zcat guppy*/*/{wildcards.barcode}/*.fastq.gz > {output}"


rule barcode_trim_l:
    input:
        "IRMA/{barcode}.fastq",
    output:
        "IRMA/{barcode}_bartrim_l.fastq",
    group:
        "trim-map"
    shell:
        "bbduk.sh"
        " in={input}"
        " out={output}"
        " hdist=3"
        " literal={config['barcodes'][wildcards.barcode]['barcode_sequence']}"
        " ktrim=l"
        " k=17"
        " qin=33"
        " rcomp=f"


rule barcode_trim_r:
    input:
        "IRMA/{barcode}_bartrim_l.fastq",
    output:
        "IRMA/{barcode}_bartrim_lr.fastq",
    group:
        "trim-map"
    shell:
        "bbduk.sh"
        " in={input}"
        " out={output}"
        " hdist=3"
        " literal={config['barcodes'][wildcards.barcode]['barcode_sequence_rc']}"
        " ktrim=r"
        " k=17"
        " qin=33"
        " rcomp=f"


rule cutadapt:
    input:
        "IRMA/{barcode}_bartrim_lr.fastq",
    output:
        "IRMA/{barcode}_bartrim_lr_cutadapt.fastq",
    group:
        "trim-map"
    conda:
        "../envs/cutadaptenv.yaml"
    shell:
        "cutadapt -u 30 -u -30 -o {output} {input}"


rule irma:
    input:
        "IRMA/{barcode}_bartrim_lr_cutadapt.fastq",
    output:
        temp(touch("IRMA/{barcode}.irma.fin")),
    group:
        "trim-map"
    threads: 16
    shell:
        "{workflow.basedir}/scripts/irmawrapper.sh"
        " {config[irmamodule]}"
        " {input}"
        " {wildcards.barcode}"


# Pipeline waits here for all samples to produce the checkpoint input needed here
# and then reevaluates the needed DAG for each sample.
checkpoint checkirma:
    input:
        ancient("IRMA/{barcode}.irma.fin"),
    output:
        temp("IRMA/{barcode}.irma.decision"),
    shell:
        "[[ -f IRMA/{wildcards.barcode}/SARS-CoV-2.bam ]] &&"
        " echo passed > {output} ||"
        " echo failed > {output}"


def passed_irma(wildcards):
    with checkpoints.checkirma.get(barcode=wildcards.barcode).output[0].open() as f:
        if f.read().strip() == "passed":
            return "IRMA/{barcode}/SARS-CoV-2_realign_{barcode}.bam"
        else:
            return "IRMA_negative/{barcode}"


rule pass_negatives:
    input:
        ancient("IRMA/{barcode}.irma.decision"),
    output:
        "IRMA_negative/{barcode}",
    shell:
        "touch {output}"


rule align2ref:
    input:
        decision=ancient("IRMA/{barcode}.irma.decision"),
    output:
        "IRMA/{barcode}/aligned2ref.fasta",
    group:
        "index-irma-tablePositions2ref"
    shell:
        "cat"
        " IRMA/{wildcards.barcode}/intermediate/0-ITERATIVE-REFERENCES/R0-SARS-CoV-2.ref"
        " IRMA/{wildcards.barcode}/SARS-CoV-2.fasta"
        " | muscle > {output}"


rule realignIrma_allAlleles:
    input:
        ancient("IRMA/{barcode}/aligned2ref.fasta"),
    output:
        "IRMA/{barcode}/tables/SARS-CoV-2-allAlleles_realign.txt",
    group:
        "index-irma-tablePositions2ref"
    shell:
        "PERL5LIB='' &&"
        " {workflow.basedir}/scripts/alignPositionByPSA.pl"
        " {input}"
        " IRMA/{wildcards.sample}/tables/SARS-CoV-2-allAlleles.txt"
        " -F 2"
        " > {output}"


# rule cat_allAlleles:


rule bam2fastq:
    input:
        decision=ancient("IRMA/{barcode}.irma.decision"),
        bam=ancient("IRMA/{barcode}/SARS-CoV-2.bam"),
    output:
        temp("IRMA/{barcode}/SARS-CoV-2.bam.fastq"),
    group:
        "realignbam"
    shell:
        "samtools fastq {input.bam} > {output}"


rule minimap2:
    input:
        ref=ancient(
            "IRMA/{barcode}/intermediate/0-ITERATIVE-REFERENCES/R0-SARS-CoV-2.ref"
        ),
        fq="IRMA/{barcode}/SARS-CoV-2.bam.fastq",
    output:
        temp("IRMA/{barcode}/SARS-CoV-2.bam.mmp2.sam"),
    group:
        "realignbam"
    shell:
        # NOTE: default mm2 is 3 CPUs... dont we wanna expose numCPUs avail here?
        "minimap2 -a {input.ref} {input.fq} > {output}"


rule bamindex:
    input:
        ancient("IRMA/{barcode}/SARS-CoV-2.bam.mmp2.sam"),
    output:
        "IRMA/{barcode}/SARS-CoV-2_realign_{barcode}.bam",
    group:
        "realignbam"
    shell:
        """
        samtools view -bS {input} | samtools sort > {output}
        samtools index {output}
        """


rule irmaroundup:
    input:
        passed_irma,
    output:
        temp("{barcode}.fin"),
    shell:
        "touch {output}"
