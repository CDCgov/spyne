#!/usr/bin/env snakemake


import os
import sys


shell.executable("bash")


workdir: "."
configfile: "tests/config.yaml"


rule all:
    input:
        expand("{barcode}.fin", barcode=config["barcodes"].keys())


rule gather_fastqs:
    input:
        fastqs=lambda wildcards: config["barcodes"][wildcards.barcode]["fastqs"]
    output:
        "IRMA/{barcode}.fastq"
    message: "Step 1 - merging all read files into a single file"
    shell:
        "zcat tests/data/*.fastq.gz > {output}"


rule barcode_trim_l:
    input:
        "IRMA/{barcode}.fastq"
    output:
        "IRMA/{barcode}_bartrim_l.fastq"
    log:
        out=".{barcode}.bbduk.trim_left.stdout",
        err=".{barcode}.bbduk.trim_left.stderr"
    params:
        barcode_sequence = lambda wildcards: config["barcodes"][wildcards.barcode]["barcode_sequence"]
    group:
        "trim-map"
    conda:
        "envs/bbduk.yaml"
    threads: 16
    message: "Step 2 - trimming left barcode"
    shell:
        "bbduk.sh"
        " in={input}"
        " out={output}"
        " hdist=3"
        " literal={params.barcode_sequence}"
        " ktrim=l"
        " k=17"
        " qin=33"
        " rcomp=f"
        " threads={threads}"
        " 1> {log.out}"
        " 2> {log.err}"


rule barcode_trim_r:
    input:
        "IRMA/{barcode}_bartrim_l.fastq"
    output:
        "IRMA/{barcode}_bartrim_lr.fastq"
    log:
        out=".{barcode}.bbduk.trim_right.stdout",
        err=".{barcode}.bbduk.trim_right.stderr"
    params:
        barcode_sequence = lambda wildcards: config["barcodes"][wildcards.barcode]["barcode_sequence"]
    group:
        "trim-map"
    conda:
        "envs/bbduk.yaml"
    threads: 16
    message: "Step 3 - trimming right barcode"
    shell:
        "bbduk.sh"
        " in={input}"
        " out={output}"
        " hdist=3"
        " literal={params.barcode_sequence}"
        " ktrim=r"
        " k=17"
        " qin=33"
        " rcomp=f"
        " threads={threads}"
        " 1> {log.out}"
        " 2> {log.err}"


rule cutadapt:
    input:
        "IRMA/{barcode}_bartrim_lr.fastq"
    output:
        "IRMA/{barcode}_bartrim_lr_cutadapt.fastq"
    group:
        "trim-map"
    conda:
        "envs/cutadapt.yaml"
    message: "Step 4 - clipping reads on both sides"
    shell:
        "cutadapt -u 30 -u -30 -o {output} {input}"


rule irma:
    input:
        "IRMA/{barcode}_bartrim_lr_cutadapt.fastq"
    output:
        temp(touch("IRMA/{barcode}.irma.fin"))
    group:
        "trim-map"
    threads: 16
    message: "Step 5 - assembling genome"
    shell:
        "{workflow.basedir}/scripts/irmawrapper.sh"
        " {config[irmamodule]}"
        " {input}"
        " {wildcards.barcode}"


# Pipeline waits here for all samples to produce the checkpoint input needed here
# and then reevaluates the needed DAG for each sample.
checkpoint checkirma:
    input:
        ancient("IRMA/{barcode}.irma.fin")
    output:
        temp("IRMA/{barcode}.irma.decision")
    shell:
        "[[ -f IRMA/{wildcards.barcode}/SARS-CoV-2.bam ]] &&"
        " echo passed > {output} ||"
        " echo failed > {output}"


def passed_irma(wildcards):
    with checkpoints.checkirma.get(barcode=wildcards.barcode).output[0].open() as f:
        if f.read().strip() == "passed":
            return "IRMA/{barcode}/SARS-CoV-2_realign_{barcode}.bam"
        else:
            return "IRMA_negative/{barcode}"


rule pass_negatives:
    input:
        ancient("IRMA/{barcode}.irma.decision")
    output:
        "IRMA_negative/{barcode}"
    shell:
        "touch {output}"
'''

rule align2ref:
    input:
        decision=ancient("IRMA/{barcode}.irma.decision")
    output:
        "IRMA/{barcode}/aligned2ref.fasta"
    group:
        "index-irma-tablePositions2ref"
    conda:
        "envs/muscle.yaml"
    shell:
        "cat"
        " IRMA/{wildcards.barcode}/intermediate/0-ITERATIVE-REFERENCES/R0-SARS-CoV-2.ref"
        " IRMA/{wildcards.barcode}/SARS-CoV-2.fasta"
        " | muscle > {output}"


rule realignIrma_allAlleles:
    input:
        ancient("IRMA/{barcode}/aligned2ref.fasta")
    output:
        "IRMA/{barcode}/tables/SARS-CoV-2-allAlleles_realign.txt"
    group:
        "index-irma-tablePositions2ref"
    shell:
        "PERL5LIB='' &&"
        " {workflow.basedir}/scripts/alignPositionByPSA.pl"
        " {input}"
        " IRMA/{wildcards.sample}/tables/SARS-CoV-2-allAlleles.txt"
        " -F 2"
        " > {output}"


# rule cat_allAlleles:


rule bam2fastq:
    input:
        decision=ancient("IRMA/{barcode}.irma.decision"),
        bam=ancient("IRMA/{barcode}/SARS-CoV-2.bam")
    output:
        temp("IRMA/{barcode}/SARS-CoV-2.bam.fastq")
    group:
        "realignbam"
    conda:
        "envs/samtools.yaml"
    shell:
        "samtools fastq {input.bam} > {output}"


rule minimap2:
    input:
        ref=ancient(
            "IRMA/{barcode}/intermediate/0-ITERATIVE-REFERENCES/R0-SARS-CoV-2.ref"
        ),
        fq="IRMA/{barcode}/SARS-CoV-2.bam.fastq"
    output:
        temp("IRMA/{barcode}/SARS-CoV-2.bam.mmp2.sam")
    group:
        "realignbam"
    conda:
        "envs/minimap2.yaml"
    threads: 16
    shell:
        # NOTE: default mm2 is 3 CPUs... dont we wanna expose numCPUs avail here?
        "minimap2 -t {threads} -a {input.ref} {input.fq} > {output}"


rule bamindex:
    input:
        ancient("IRMA/{barcode}/SARS-CoV-2.bam.mmp2.sam")
    output:
        "IRMA/{barcode}/SARS-CoV-2_realign_{barcode}.bam"
    group:
        "realignbam"
    conda:
        "envs/samtools.yaml"
    shell:
        """
        samtools view -bS {input} | samtools sort > {output}
        samtools index {output}
        """
'''

rule irmaroundup:
    input:
        passed_irma
    output:
        temp("{barcode}.fin")
    shell:
        "touch {output}"
