#!/usr/bin/env snakemake


import os
import sys


shell.executable("bash")


workdir: "."
configfile: "tests/config.yaml"


rule all:
    input:
        expand("{barcode}.fin", barcode=config["barcodes"].keys())


rule gather_fastqs:
    input:
        fastqs=lambda wildcards: config["barcodes"][wildcards.barcode]["fastqs"]
    output:
        "IRMA/{barcode}.fastq"
    message: "Step 1 - merging all read files into a single file"
    shell:
        "zcat tests/data/tiny-test.fastq.gz > {output}"


rule plot_read_lengths:
    input:
        "IRMA/{barcode}.fastq"
    output:
        "qa/{barcode}.png"
    log:
        out = "log/{barcode}.plot-read-lengths.stdout.log",
        err = "log/{barcode}.plot-read-lengths.stderr.log"
    group:
        "trim-map"
    conda:
        "envs/plot.read-lengths.yaml"
    threads: 16
    message: "Step X - plotting sequence read lengths"
    script:
        "{workflow.basedir}/scripts/plot.read-lengths.py"
        " --indir IRMA"
        " --prefix {barcode}"
        " --cpus {threads}"
        " --outfile {output}"
        " --title 'Sample_ID and Experiment_ID'"
        " --subtitle {barcode}"
        " 1> {log.out}"
        " 2> {log.err}"


rule barcode_trim_left:
    input:
        "IRMA/{barcode}.fastq"
    output:
        "IRMA/{barcode}_bartrim_l.fastq"
    log:
        out = "log/{barcode}.bbduk.trim_left.stdout.log",
        err = "log/{barcode}.bbduk.trim_left.stderr.log"
    params:
        barcode_sequence = lambda wildcards: config["barcodes"][wildcards.barcode]["barcode_sequence"]
    group:
        "trim-map"
    # conda:
    #     "envs/bbtools.yaml"
    threads: 16
    message: "Step 2 - trimming left barcode"
    shell:
        "/apps/x86_64/bbmap/38.84/bbduk.sh"
        " in={input}"
        " out={output}"
        " hdist=3"
        " literal={params.barcode_sequence}"
        " ktrim=l"
        " k=17"
        " qin=33"
        " rcomp=f"
        " threads={threads}"
        " 1> {log.out}"
        " 2> {log.err}"


rule summarize_barcode_trim_left:
    input:
        "log/{barcode}.bbduk.trim_left.stderr.log"
    output:
        "qa/stats.{barcode}_left_barcode_trimming.tsv"
    group:
        "trim-map"
    message: "Step X - summarizing left barcode trimming"
    shell:
        "scripts/grep_summarize_bbduk_log.sh {input} > {output}"


rule barcode_trim_right:
    input:
        "IRMA/{barcode}_bartrim_l.fastq"
    output:
        "IRMA/{barcode}_bartrim_lr.fastq"
    log:
        out = "log/{barcode}.bbduk.trim_right.stdout.log",
        err = "log/{barcode}.bbduk.trim_right.stderr.log"
    params:
        barcode_sequence = lambda wildcards: config["barcodes"][wildcards.barcode]["barcode_sequence"]
    group:
        "trim-map"
    # conda:
    #     "envs/bbtools.yaml"
    threads: 16
    message: "Step 3 - trimming right barcode"
    shell:
        "/apps/x86_64/bbmap/38.84/bbduk.sh"
        " in={input}"
        " out={output}"
        " hdist=3"
        " literal={params.barcode_sequence}"
        " ktrim=r"
        " k=17"
        " qin=33"
        " rcomp=f"
        " threads={threads}"
        " 1> {log.out}"
        " 2> {log.err}"


rule summarize_barcode_trim_right:
    input:
        "log/{barcode}.bbduk.trim_right.stderr.log"
    output:
        "qa/stats.{barcode}_right_barcode_trimming.tsv"
    group:
        "trim-map"
    message: "Step X - summarizing right barcode trimming"
    script:
        "scripts/grep_summarize_bbduk_log.sh {input} > {output}"


rule cutadapt:
    input:
        "IRMA/{barcode}_bartrim_lr.fastq"
    output:
        "IRMA/{barcode}_bartrim_lr_cutadapt.fastq"
    log:
        out = "log/{barcode}.cutadapt.stdout.log",
        err = "log/{barcode}.cutadapt.stderr.log"
    group:
        "trim-map"
    conda:
        "envs/cutadapt.yaml"
    message: "Step 4 - clipping reads on both sides"
    shell:
        "cutadapt -u 30 -u -30 -o {output} {input} 1> {log.out} 2> {log.err}"


rule summarize_cutadapt:
    input:
        "log/{barcode}.cutadapt.stdout.log"
    output:
        "qa/stats.{barcode}.cutadapt.tsv"
    group:
        "trim-map"
    message: "Step X - summarizing cutadapt trimming"
    script:
        """
        cnt_input_reads=$(grep '^Total reads' {input} | awk '{print $4}')
        cnt_input_bases=$(grep '^Total basepairs' {input} | awk '{print $4}' | sed 's/,//g')
        cnt_adapters=$(grep '^Reads with adapters:' {input} | awk '{print $4}' | sed 's/,//g')
        cnt_output_reads=$(( "${cnt_input_reads}" - "${cnt_adapters}" ))
        cnt_output_bases=$(grep '^Total written' {input} | awk '{print $4}' | sed 's/,//g')
        nfo="${cnt_input_reads} input reads\t${cnt_input_bases} input bases\t"
        nfo+="${cnt_output_reads} output reads \t${cnt_output_bases} output bases"
        echo -e "${nfo}" > {output}
        """


# rule subsample:
#     input:
#         "IRMA/{barcode}_bartrim_lr_cutadapt.fastq"
#     output:
#         "IRMA/{barcode}_bartrim_lr_cutadapt.fastq"
#     log:
#         # out = "log/{barcode}.seqtk.stdout.log",
#         err = "log/{barcode}.seqtk.stderr.log"
#     group:
#         "trim-map"
#     conda:
#         "envs/seqtk.yaml"
#     message: "Step 4b - subsampling cleaned up read if excess > 1M exist"
#     shell:
#         "seqtk sample -s608 {input} 1000000 1> {output} 2> {log.err}"


rule subsample:
    input:
        "IRMA/{barcode}_bartrim_lr_cutadapt.fastq"
    output:
        "IRMA/{barcode}_bartrim_lr_cutadapt_subsampled.fastq"
    log:
        out = "log/{barcode}.reformat.stdout.log",
        err = "log/{barcode}.reformat.stderr.log"
    group:
        "trim-map"
    # conda:
    #     "envs/bbtools.yaml"
    message: "Step 4b - subsampling cleaned up read if excess > 1M exist"
    shell:
        "/apps/x86_64/bbmap/38.84/reformat.sh"
        " in={input}"
        " out={output}"
        " samplereadstarget=1000000"
        " qin=33"
        " 1> {log.out}"
        " 2> {log.err}"


rule summarize_subsample:
    input:
        "log/{barcode}.reformat.stderr.log"
    output:
        "qa/stats.{barcode}.subsample.tsv"
    group:
        "trim-map"
    message: "Step X - summarizing subsampling"
    script:
        """
        cnt_input_reads=$(grep '^Input:' {input} | awk '{print $2}')
        cnt_input_bases=$(grep '^Input:' {input} | awk '{print $5}')
        cnt_output_reads=$(grep '^Output:' {input} | awk '{print $2}')
        cnt_output_bases=$(grep '^Output:' {input} | awk '{print $5}')
        cnt_discarded_reads=$(( "${cnt_input_reads}" - "${cnt_output_reads}" ))
        cnt_discarded_bases=$(( "${cnt_input_bases}" - "${cnt_output_bases}" ))
        nfo="${cnt_discarded_reads} discarded reads\t"
        nfo+="${cnt_discarded_bases} discarded bases"
        echo -e "${nfo}" > {output}
        """


rule irma:
    input:
        "IRMA/{barcode}_bartrim_lr_cutadapt_subsampled.fastq"
    output:
        temp(touch("IRMA/{barcode}.irma.fin"))
    log:
        out = "log/{barcode}.irma.stdout.log",
        err = "log/{barcode}.irma.stderr.log"
    group:
        "trim-map"
    threads: 16
    message: "Step 5 - assembling genome"
    shell:
        "{workflow.basedir}/scripts/irmawrapper.sh"
        " {config[irmamodule]}"
        " {input}"
        " {wildcards.barcode}"
        " 1> {log.out}"
        " 2> {log.err}"


rule quast:
    input:
        "IRMA/{barcode}/SARS-CoV-2.fasta"
    output:
        temp("qa/.tmp/{barcode}/transposed_report.tsv")
    log:
        out = "log/{barcode}.quast.stdout.log",
        err = "log/{barcode}.quast.stderr.log"
    group:
        "trim-map"
    conda:
        "envs/quast.yaml"
    threads: 16
    message: "Step 5b - calculating assembly metrics"
    shell:
        "quast"
        " --fast"
        " --threads {threads}"
        " --output-dir qa/.tmp/{barcode}"
        " {input}"


rule report_assembly_statistics:
    input:
        "qa/.tmp/{barcode}/transposed_report.tsv"
    output:
        "qa/{barcode}-assembly-stats.tsv"
    group:
        "trim-map"
    message: "Step 5c - moving assembly metrics"
    shell:
        "mv {input} {output}"

# Pipeline waits here for all samples to produce the checkpoint input needed
#  here and then reevaluates the needed DAG for each sample.
checkpoint checkirma:
    input:
        ancient("IRMA/{barcode}.irma.fin")
    output:
        temp("IRMA/{barcode}.irma.decision")
    shell:
        "[[ -s IRMA/{wildcards.barcode}/SARS-CoV-2.bam ]] &&"
        " echo passed > {output} ||"
        " echo failed > {output}"


def passed_irma(wildcards):
    with checkpoints.checkirma.get(barcode=wildcards.barcode).\
    output[0].open() as f:
        if f.read().strip() == "passed":
            return "IRMA/{barcode}/SARS-CoV-2.bam"
        else:
            return "IRMA_negative/{barcode}"


rule pass_negatives:
    input:
        ancient("IRMA/{barcode}.irma.decision")
    output:
        "IRMA_negative/{barcode}"
    shell:
        "touch {output}"
'''

rule align2ref:
    input:
        decision=ancient("IRMA/{barcode}.irma.decision")
    output:
        "IRMA/{barcode}/aligned2ref.fasta"
    group:
        "index-irma-tablePositions2ref"
    conda:
        "envs/muscle.yaml"
    shell:
        "cat"
        " IRMA/{wildcards.barcode}/intermediate/0-ITERATIVE-REFERENCES/R0-SARS-CoV-2.ref"
        " IRMA/{wildcards.barcode}/SARS-CoV-2.fasta"
        " | muscle > {output}"


rule realignIrma_allAlleles:
    input:
        ancient("IRMA/{barcode}/aligned2ref.fasta")
    output:
        "IRMA/{barcode}/tables/SARS-CoV-2-allAlleles_realign.txt"
    group:
        "index-irma-tablePositions2ref"
    shell:
        "PERL5LIB='' &&"
        " {workflow.basedir}/scripts/alignPositionByPSA.pl"
        " {input}"
        " IRMA/{wildcards.sample}/tables/SARS-CoV-2-allAlleles.txt"
        " -F 2"
        " > {output}"


# rule cat_allAlleles:


rule bam2fastq:
    input:
        decision=ancient("IRMA/{barcode}.irma.decision"),
        bam=ancient("IRMA/{barcode}/SARS-CoV-2.bam")
    output:
        temp("IRMA/{barcode}/SARS-CoV-2.bam.fastq")
    group:
        "realignbam"
    conda:
        "envs/samtools.yaml"
    shell:
        "samtools fastq {input.bam} > {output}"


rule minimap2:
    input:
        ref=ancient(
            "IRMA/{barcode}/intermediate/0-ITERATIVE-REFERENCES/R0-SARS-CoV-2.ref"
        ),
        fq="IRMA/{barcode}/SARS-CoV-2.bam.fastq"
    output:
        temp("IRMA/{barcode}/SARS-CoV-2.bam.mmp2.sam")
    group:
        "realignbam"
    conda:
        "envs/minimap2.yaml"
    threads: 16
    shell:
        # NOTE: default mm2 is 3 CPUs... dont we wanna expose numCPUs avail here?
        "minimap2 -t {threads} -a {input.ref} {input.fq} > {output}"


rule bamindex:
    input:
        ancient("IRMA/{barcode}/SARS-CoV-2.bam.mmp2.sam")
    output:
        "IRMA/{barcode}/SARS-CoV-2_realign_{barcode}.bam"
    group:
        "realignbam"
    conda:
        "envs/samtools.yaml"
    shell:
        """
        samtools view -bS {input} | samtools sort > {output}
        samtools index {output}
        """
'''

rule irmaroundup:
    input:
        passed_irma
    output:
        temp("{barcode}.fin")
    shell:
        "touch {output}"
